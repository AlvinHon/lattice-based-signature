//! Defines the verification key and its methods.

use digest::Digest;
use num::BigInt;

use crate::{field::Elem, hash::hash, params::Params};
use poly_ring::Polynomial;

use super::signature::Signature;

/// The verification key generated by the verifying algorithm which takes
/// a setup with prime modulus P.
#[derive(Clone, Debug)]
pub struct VerificationKey<const P: u32, const N: usize> {
    pub(crate) a: Polynomial<Elem<P>, N>,
    pub(crate) t: Polynomial<Elem<P>, N>,
}

impl<const P: u32, const N: usize> VerificationKey<P, N> {
    /// Verify a signature against a message.
    ///
    /// This method requires digest `H` from [Digest] because signature scheme
    /// does not specify how the message is hashed into some bytes. Hence, it
    /// is up to the caller to provide a hash algorithm.
    pub fn verify<H: Digest>(
        &self,
        params: &Params<P, N>,
        message: &[u8],
        signature: &Signature<P, N>,
    ) -> bool {
        let Params { r, k } = params;
        let Signature { z1, z2, c } = signature;
        let bound = BigInt::from(k - 32);

        if !r.is_valid_within(z1, &bound) || !r.is_valid_within(z2, &bound) {
            return false;
        }

        let c_prime = {
            let tc = r.mul(&self.t, c);
            let az1 = r.mul(&self.a, z1);
            let az1_z2 = r.add(&az1, z2);
            let az1_z2_tc = r.sub(az1_z2, tc);
            let az1_z2_tc_bytes = params.r.convert_polynomial_to_bytes(az1_z2_tc);
            hash::<_, H, N>(&[&az1_z2_tc_bytes, message].concat())
        };

        c == &c_prime
    }
}
